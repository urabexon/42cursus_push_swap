/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   coordinate_press.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hurabe <hurabe@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/15 19:36:08 by hurabe            #+#    #+#             */
/*   Updated: 2024/09/20 20:59:06 by hurabe           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

// クイックソートアルゴリズム、quicksort関数とpartition関数で構成
// クイックソートは、リストを分割しながら再帰的にソートしていくアルゴリズムのこと。
// リストの中から基準となる要素（ピボット）を選び、そのピボットを基準に小さい値と大きい値でリストを2つに分ける。
// その後、それぞれの部分リストを再帰的にソートすることで、リスト全体がソートされる

// クイックソート全体の流れ
// 1. 配列の最後の要素をピボットとして選び、そのピボットを基準に左右に値を分ける。
// 2. ピボットより小さい値は左側、大きい値は右側に集める。
// 3. ピボットを正しい位置に移動する。
// 4. その後、ピボットの左側と右側の部分配列に対して同様の操作を再帰的に行う。

// 例
// 配列 [300, 100, 200, 400] をソートする場合：
// 1. 最初にピボットとして 400 が選ばれる
// 配列はそのまま [300, 100, 200, 400] になる（400は正しい位置にある）

// 2. 次に、400の左側の部分配列 [300, 100, 200] に対して再帰的にクイックソートが行われる
// 200がピボットとして選ばれ、100と300が入れ替わり、[100, 200, 300]になる

// 3. それぞれの部分配列に対して再帰的にクイックソートを行い、全体がソートされた配列[100, 200, 300, 400]になる


// この関数がクイックソートの核心部分で、リストの一部を「ピボットを基準に左右に分割」する作業を行う
// ここではarr[high]の値をピボットとして選ぶ
// arrはソート対象の配列、lowは分割する範囲の最初のインデックス(配列の左端)、highは分割する最後のインデックス(配列の右端)
static	int	partition(long *arr, int low, int high)
{
	long	pivot;
	long	temp;
	int		i;
	int		j;

	pivot = arr[high]; // 配列の最後の要素arr[high]をピボットとして選ぶ。
	i = low - 1; //iはピボットより小さい要素を追跡するためのインデックス。実際に小さい要素を見つけた時にインクリメント
	j = low; // 配列のlowからhigh - 1までをループし、ピボットと比較して現在の要素がピボットより小さいかどうかを確認する

	// jがlowからhigh - 1までの間、arr[j]がピボットより小さい場合、iを1増やしてその位置にarr[j]を移動させる。
	// これは、ピボットより小さい値を左側に集めるため。arr[i]とarr[j]を交換することで、その位置を入れ替えている
	while (j < high)
	{
		if (arr[j] < pivot)
		{
			// jがlowからhigh - 1までの間、arr[j]がピボットより小さい場合、iを1増やしてその位置にarr[j]を移動させる
			// これは、ピボットより小さい値を左側に集めるためである
			// arr[i]とarr[j]を交換することで、その位置を入れ替えている
			i++;
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
		j++;
	}
	// 最後にピボットを正しい位置に配置する。arr[i + 1]はピボットが属するtべき場所で、ピボットより小さい値が左に、大きい値が右に位置する
	temp = arr[i + 1];
	arr[i + 1] = arr[high];
	arr[high] = temp;
	// ピボットの新しい位置を返す。これでソートの次のステップでこの位置を基準にさらに分割が行われる
	return (i + 1);
}

// クイックソートアルゴリズムの再帰部分。リストをピボットで分割し、再帰的にソートを行う
// arrはソート対象の配列、lowは分割する範囲の最初のインデックス(配列の左端)、highは分割する最後のインデックス(配列の右端)
static void	quicksort(long *arr, int low, int high)
{
	int	pivot_index;

	// 再帰条件、lowがhighより小さい場合にのみソートを続ける
	// lowとhighが同じかlowが大きくなれば再帰終了
	if (low < high)
	{
		// partition関数を使って、配列をピボットで分割する
		// ピボットの位置がpivot_indexとして返される
		pivot_index = partition(arr, low, high);
		// pivot_indexの左側と右側で、それぞれ独立してソートを行う
		// これが再帰的に行われることで、最終的に配列全体がソートされる
		quicksort(arr, low, pivot_index - 1);
		quicksort(arr, pivot_index + 1, high);
	}
}

// argvに含まれる文字列をlong型の配列に変換し、クイックソートを使ってソートした結果を返す
static long	*sort(char **argv, int len)
{
	long	*arr;
	int		i;

	arr = (long *)malloc(len * sizeof(long));
	if (!arr)
		return (NULL);
	i = 0;
	// 文字列をlong型に変換して配列に格納する
	while (i < len)
	{
		//　ft_atolでargvをlongに変換し、arr[i]に格納していく
		arr[i] = ft_atol(argv[i]);
		i++;
	}
	// クイックソートでarr配列をソートする(ソート範囲は0から-1まで、配列全体)、ソート済みのarr配列を返す
	// このソート済みの配列を使用して座標圧縮処理を行う
	quicksort(arr, 0, len - 1);
	return (arr);
}

// argvは文字列(数値として扱いたいもの)を含んだ配列、lenはargv配列の数値の個数を表している
long	*coordinate_press(char **argv, int len)
{
	long	*ret; // 座標圧縮の結果を保存するための配列、変数
	long	*arr; // ソート済みの数値を格納するための配列、変数
	int		i; // argvのインデックス用
	int		j; // ソート済み配列arrのインデックス用

	argv++; // argv[0]、./a.outをスキップして数値が格納されている部分だけを扱うようにする
	// argvに含まれている値をft_atolでlong型に変換して、数値を小さい順にソートし配列arrに代入()
	// argvが[300, 100, 200]だったら[100, 200, 300]が結果として返る
	arr = sort(argv, len);
	// 結果を保存するために配列retをmallocする、これでソートされた数値が格納される
	ret = (long *)malloc(len * sizeof(long));
	// retかarrのメモリ確保に失敗したらプログラム終了
	if (!ret || !arr)
		exit(0);
	//実際に座標圧縮を行う部分、argvの各要素が、ソートされたリストarrの中でどの位置にあるかを見つけてその結果を配列retに保存する
	// iとjを-1に初期化してwhileで前置インクリメントでiを1増やしてからiの値がlen未満であるかどうかをチェックする　
	// つまり、ループの最初の反復でi = 0 になる
	i = -1;
	while (++i < len)
	{
		// 内側のループjでは、ソート済み配列arrの中で、argv[i]と同じ値を探す
		j = -1;
		while (++j < len)
		{
			// argv[i]の値をft_atolを使って数値に変換し、それがソートされたarr[j]の値と同じかどうか確認する
			// argv[i]とarr[j]が等しければ、そのときのjの値をret[i]に保存する。argv[i]がarrの中で何番目にあるかを表している
			if (ft_atol(argv[i]) == arr[j])
			{
				// trueならret[i]にその値を格納する、breakで不要なループを回さないようにする
				ret[i] = j;
				break ;
			}
		}
	}
	// ソートされた配列arrをfreeし、座標圧縮された結果を含むretを返す(座標圧縮された値が返る)
	free(arr);
	return (ret);
}

// このコードは、リストの数値を座標圧縮するために、まず数値をソートし、その順位を元のリストに基づいて新しい配列に保存している
// これにより、元の数値を大小関係を保ったまま、連続した小さな数値に変換することができる

// 全体の流れ
// 「元の数値の大小関係を保ちながら、数値を圧縮して小さな範囲に収める」ことが目的
// 1. 元の数値リストをソート: 数値を小さい順に並べ替える。ソートすることで、元の数値が何番目に小さいかを確認できるようになる
// 2. ソート後の順番を使って順位を割り当てる: ソートされたリストの中で、各数値が何番目かを調べ、それを新しい小さな数値に置き換える。この順位が座標圧縮された値になる。
// 3. 順位を新しいリストに格納：最終的に、元のリストの各数値が何番目に小さいか（順位）を調べ、その順位を格納した新しいリストを作成する

//こうすることにより、元の数値を小さな範囲の連続する数値に置き換えることができる