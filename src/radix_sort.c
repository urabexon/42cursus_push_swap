/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   radix_sort.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hurabe <hurabe@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/11 20:41:37 by hurabe            #+#    #+#             */
/*   Updated: 2024/09/22 18:38:20 by hurabe           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

// t_dstという双方向リストを使って、リストaの要素を基数に基づいてソートする
// このアルゴリズムでは、数値のビットごとにソートを行い、小さなビットから順番に処理していくことで最終的に数値をソートする
// 数値を1の位、10の位、100の位といった桁ごとに処理してソートするアルゴリズムだが、今回はビット単位でソートする

// 最下位ビットから順番に見て、そのビットが0か1かによってリストを分ける
// 最終的にビットごとのソートを繰り返すことで、リスト全体をソートする

// 基数ソートの流れ
// 1. 各数値のビットを1つずつ確認
// 最下位ビット(i = 0)から順番に確認し、そのビットが0であればリストbに移動し、1であればリストaに残す。

// 2. リストをビット単位で分ける
// 各ビットに基づいてリストを分割する。最下位ビットから確認していくため、1回目のループで最下位ビットをつかってソートし、2回目で次のビットを使ってソートするという流れになる。

// 3. 再帰的にソートが進む
// 各ビットを確認し終えると、リスト全体がビットごとにそーとされ、最銃的にリストが完全にソートされる。

// 構造体t_dstというリスト構造体の先頭にあるノードのvalueを取得して返す関数
static long	get_top(t_dst *dst)
{
	return (dst->value);
}

// ビットごとに基数ソートで並び替える。(aのリストに格納されている数値を最も小さい順番から並べ替える。)
// ビットのため2進数で並べ替える
// aはソート対象の双方向リストの先頭、bは一時的に値を保存するためのリスト、confはソートに必要な設定情報を持つ構造体(lenやmax_numなど)
void	radix_sort(t_dst **a, t_dst **b, t_config *conf)
{
	int		max_bits; // ソート対象の数値リストの中で最も大きな数が持つビット数
	int		i; // 現在処理しているビットの位置
	int		j; // リストa内の各要素を順番に処理するためのインデックス
	long	num; // リストaの先頭にある数値を取得し、その数値のi番目のビットが1か0かを確認する

	// max_bitsはソートする最大の数が持つビット数を計算する
	// conf->maxnumはaリスト内の最大の数。この数を2進数のビットに変換した時に何ビット必要か調べる
	max_bits = 0;
	// ビットシフト>>で最大値をビットシフト、0になるまでの回数(ビット数)をカウントしている。(基数ソートで何回のループが必要かわかる)
	// 例として、最大値が15であれば、2進数にすると1111(4ビット)。よってmax_bitsは4になる
	while ((conf->max_num >> max_bits) != 0)
		max_bits++;
	// iはビット位置を示していて、最初は最下位ビット(1の位のビット)から処理を始める
	i = 0;
	// i < max_bitsで最大ビット数までソートを繰り返す
	// is_sorted_ascending(a)はaリストがすでに昇順にソートされているかを確認する
	while (i < max_bits && !is_ascending(a))
	{
		// jはaリスト内の各要素を順番に処理するための変数
		j = 0;
		while (j < conf->len)
		{
			// get_topはリストの先頭の値を返す関数のためaリストの先頭を取得
			// num & (1 << i)は数値numのi番目のビットを確認している
			// 1 << iは1をiビットだけ左にシフトさせた値。iが0なら1の位のビットを確認する
			num = get_top(*a);
			if (num & (1 << i))
				// numのi番目のビットが1なら、ra(a)を呼び出してリストaの値を回転させる
				ra(a);
			else
				// 0ならpb(a, b)を呼び出して、その値をリストbに移動させる(リストbに一時的に保存)
				// これにより、ビットが0の値はbに、ビットが1の値はaに残される
				pb(a, b);
			j++;
		}
		// 一時的にbに移動させた数値を、pa(a, b)で再びリストaに戻す。
		// これでビットごとのソートが完了する、i++で次のビットへ進む。
		while (*b)
			pa(a, b);
		i++;
	}
}
